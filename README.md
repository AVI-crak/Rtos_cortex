Небольшая по объёму ос с вытеснением по времени + приоритеты на 3 уровня. 
Задачи могут использовать математику, при этом обработка стека зависит от включенной/выключенной математики. Так как задач с математикой обычно намного меньше простых - вход в прерывания пользователя выполняются намного быстрее. Количество задач ограничено размером памяти мк и числом 253.

[b]1)[/b] Активные задачи [b]struct task* activ[/b] выполняются последовательно и постоянно. 
Время работы каждой отдельной задачи можно задать разным (в процентах 1-100), что является аналогом приоритета выполнения.
Важной функцией этой Ос является команда [b]os_pass()[/b], которая предназначена для добровольного переключения в момент когда задаче нечего делать.

[b]2)[/b] Задачи которые выполняются с нормированным временным интервалом, либо через внешнее событие. Ос использует программное прерывание [b]SVC_Handler[/b] - которое невозможно вытеснить в нормальном режиме работы. Таким образом достигается эксклюзивное выполнение кода без блокировок прерываний. Важно заметить - что обработка задач происходит в моменты внешних событий практически моментально, без длительных задержек. Точно так-же как и любое другое прерывание в этой системе.
[b]os_Delay_ms(мс)[/b] стандартная задержка выполнения кода в мс. Обработка s[b]truct task* delay;[/b] происходит каждые 1мс по системному таймеру TIM6 (можно изменить), которое определяет общее время [b]system_us[/b].
Задачу можно заморозить [b]os_freeze(* global_flag)[/b], и разбудить из этого состояния [b]os_wake(* global_flag)[/b] (из задачи или прерывания). Время нахождения задачи в [b]struct task* hold[/b] не ограничено, а для доступа необходимо знать "временный пароль". В этом случае задача должна сначала сообщить это "временный пароль" тому событию или задаче - которая будет её будить.

[b]3)[/b] Функции что требуют много процессорного времени - выполняются в системной задаче [b]service()[/b], которая обслуживает [b]struct task* service;[/b] и печать состояния Ос на внешний терминал.
Это выделение памяти [b]os_malloc[/b], удаление памяти [b]os_free[/b], запуск новой задачи [b]os_Task_new[/b], удаление задачи [b]os_Task_del[/b], а так-же сбор данных о системе.

Запуск Ос однократный из [b]main()[/b] функцией [b]os_Run()[/b]. До запуска необходимо по возможности настроить всю периферию, для этих целей существует  [b]SystemInit()[/b].
Для того чтобы не бороться с ветряными мельницами, стек [b]main()[/b] был принудительно смещён вниз на размер стека прерываний [b]_irqsize[/b], относительно [b]_estack[/b] - который задаётся в таблице прерываний. Для файла startup_stm32fxxxx.s необходимо добавить и изменить строки:
[code] .equ   _irqsize, 600
 .equ   _main_stask,         ( _estack -   ((_irqsize + 200) & 0xFFFFFFF8))
 .equ   _irq_stack,          _estack[/code][code]g_pfnVectors:
  .word  _main_stask
  .word  Reset_Handler
 
  .word  NMI_Handler
  .word  HardFault_Handler
  .word  MemManage_Handler
  .word  BusFault_Handler
  .word  UsageFault_Handler
  .word  _irq_stack               /* добавить              */
  .word  _irqsize                   /* добавить              */
  .word  _ebss                      /* добавить              */
  .word  0
  .word  SVC_Handler
  .word  DebugMon_Handler
  .word  0
  .word  PendSV_Handler
  .word  SysTick_Handler[/code]
  
  Если g_pfnVectors не имеет пробелов в местах модификаций - то придётся менять часть алгоритма последующей обработки. Это не так сложно как кажется.

Простые CMSIS функции включения и выключения прерываний в условиях работы Ос запрещены, режим запрещает доступ к этим регистрам. 
Установка через [b]os_EnableIRQ(IRQn_Type IRQn, uint8_t priority)[/b], при этом приоритет от 1 до 14. Да, в CMSIS использует значения от 0 до 255, но физически регистр может вместить в себя всего 4 бита, да и то не всегда.
Удаление [b]os_DisableIRQ(IRQn_Type IRQn)[/b]. 

Для эксклюзивного доступа к аппаратным физическим интерфейсам, или области памяти - используются функции запроса ресурса [b]os_resource_ask[/b], и освобождение ресурса [b]os_resource_free[/b].

Генератор случайных цифр имеет аппаратное решение для M4 и M7 [b]os_Ranlom(range)[/b] с проверкой на слепые зоны.

репозиторий [url=https://github.com/AVI-crak/Rtos_cortex]https://github.com/AVI-crak/Rtos_cortex[/url]
Средство контроля версий - черепаха [url=https://tortoisegit.org/]https://tortoisegit.org/[/url].